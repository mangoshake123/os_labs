###### Bash Codes:


1.	Convert Decimal to binary & binary to decimal:




#tput clear
echo "Conversion of decimal to Binary and Binary to Decimal"
echo "1. Convert Decimal to Binary"
echo "2. Convert Binary to Decimal"
echo "3. Exit"
echo "Enter ur choice:"
read ch
case $ch in
1) echo "Enter any decimal no:"
read 
rem=1
bno=" "
while [ $num -gt 0 ]
do
rem=`expr $num % 2 `
bno=$bno$rem
num=`expr $num / 2 `
done
i=${#bno}
final=" "
while [ $i -gt 0 ]
do
rev=`echo $bno | awk '{ printf substr( $0,'$i',1 ) }'`
final=$final$rev
i=$(( $i - 1 ))
done
echo "Equivalent Binary no:" $final ;;
2) echo "Enter any Binary no;"
read bino
len=${#bino}
i=1
pow=$((len - 1 ))
while [ $i -le $len ]
do
n=`echo $bino | awk '{ printf substr( $0,'$i',1 )}' `
j=1
p=1
while [ $j -le $pow ]
do
p=$(( p * 2 ))
j=$(( j + 1 ))
done
dec=$(( n * p ))
findec=$(( findec + dec ))
pow=$((pow - 1 ))
i=$(( i + 1 ))
done
echo "Equivalent Decimal no:"$findec ;;
3) echo "Enter correctly:" ;;
esac






2.Sort array using any sorting method (Bubble here)





# Sorting the array in Bash 
# using Bubble sort

# Static input of Array
arr=(10 8 20 100 12)

echo "Array in original order"
echo ${arr[*]}

# Performing Bubble sort 
for ((i = 0; i<5; i++))
do
    
    for((j = 0; j<5-i-1; j++))
    do
    
        if [ ${arr[j]} -gt ${arr[$((j+1))]} ]
        then
            # swap
            temp=${arr[j]}
            arr[$j]=${arr[$((j+1))]}  
            arr[$((j+1))]=$temp
        fi
    done
done

echo "Array in sorted order :"
echo ${arr[*]}







3.Prime Number Check






#storing the number to be checked 
echo "Enter no."
read number
i=2 

#flag variable 
f=0 

#running a loop from 2 to number/2 
while test $i -le `expr $number / 2` 
do

#checking if i is factor of number 
if test `expr $number % $i` -eq 0 
then
f=1 
fi

#increment the loop variable 
i=`expr $i + 1` 
done
if test $f -eq 1 
then
echo "Not Prime"
else
echo "Prime"
fi






4. Reversing a number







echo "Enter a number"
read num
reverse=0
 
while [ $num -gt 0 ]
do
    remainder=$(( $num % 10 )) 
    reverse=$(( $reverse * 10 + $remainder )) 
    num=$(( $num / 10 )) 
done
 
echo "Reversed number is : $reverse"







5. Save even and odd in different files






#!/bin/bash

# Check if the input file is provided
if [ "$#" -ne 1 ]; then
  echo "Usage: $0 input_file"
  exit 1
fi

input_file=$1

# Check if the input file exists
if [ ! -f "$input_file" ]; then
  echo "File not found: $input_file"
  exit 1
fi

# Clear or create the output files
> even.txt
> odd.txt

# Read numbers from the input file
while IFS= read -r number; do
  # Check if the number is even or odd
  if [ $((number % 2)) -eq 0 ]; then
    echo "$number" >> even.txt
  else
    echo "$number" >> odd.txt
  fi
done < "$input_file"

echo "Processing complete. Check 'even' and 'odd' files for results."

Running:
chmod +x evod.sh
./evod.sh input.txt






6. Arithmetic functions





#!/bin/sh

a=10
b=20

val=`expr $a + $b`
echo "a + b : $val"

val=`expr $a - $b`
echo "a - b : $val"

val=`expr $a \* $b`
echo "a * b : $val"

val=`expr $b / $a`
echo "b / a : $val"

val=`expr $b % $a`
echo "b % a : $val"

if [ $a == $b ]
then
   echo "a is equal to b"
fi

if [ $a != $b ]
then
   echo "a is not equal to b"
fi









7. String Handling Functions







#!/bin/bash

# Function to get the length of a string
string_length() {
  local str=$1
  echo "Length of '$str' is ${#str}"
}

# Function to extract a substring
substring() {
  local str=$1
  local position=$2
  local length=$3
  echo "Substring of '$str' from position $position with length $length is '${str:position:length}'"
}

# Function to replace a substring
string_replace() {
  local str=$1
  local search=$2
  local replace=$3
  echo "String after replacing '$search' with '$replace' in '$str' is '${str//$search/$replace}'"
}

# Function to convert string to uppercase
string_uppercase() {
  local str=$1
  echo "Uppercase of '$str' is '${str^^}'"
}

# Function to convert string to lowercase
string_lowercase() {
  local str=$1
  echo "Lowercase of '$str' is '${str,,}'"
}

# Main script execution

# Sample string
sample_string="Hello, World!"

# Get the length of the string
string_length "$sample_string"

# Extract a substring
substring "$sample_string" 7 5

# Replace a substring
string_replace "$sample_string" "World" "Bash"

# Convert to uppercase
string_uppercase "$sample_string"

# Convert to lowercase
string_lowercase "$sample_string"






8. Fibonnachi





# Program for Fibonacci
# Series

# Static input for N
N=9

# First Number of the
# Fibonacci Series
a=0

# Second Number of the
# Fibonacci Series
b=1 

echo "The Fibonacci series is : "

for (( i=0; i<N; i++ ))
do
	echo -n "$a "
	fn=$((a + b))
	a=$b
	b=$fn
done
# End of for loop









9. Palindrome





num=545

# Storing the remainder
s=0

# Store number in reverse 
# order
rev=""

# Store original number 
# in another variable
temp=$num

while [ $num -gt 0 ]
do
	# Get Remainder
	s=$(( $num % 10 )) 
	
	# Get next digit
	num=$(( $num / 10 )) 
	
	# Store previous number and
	# current digit in reverse 
	rev=$( echo ${rev}${s} ) 
done

if [ $temp -eq $rev ];
then
	echo "Number is palindrome"
else
	echo "Number is NOT palindrome"
fi







10. Even Odd





# HOW TO FIND A NUMBER IS EVEN OR ODD IN SHELL SCRIPT
clear 
echo "---- EVEN OR ODD IN SHELL SCRIPT -----";
echo -n "Enter a number:";
read n;
echo -n "RESULT: ";
if [ `expr $n % 2` == 0 ]
then
	echo "$n is even";
else
	echo "$n is Odd";
fi








11. Sum of n even numbers cmd line input




#!/bin/bash

# Function to calculate the sum of first n even numbers
sum_even_numbers() {
    local n=$1
    local sum=0
    local i=1

    while [ $i -le $n ]; do
        # Calculate the i-th even number
        local even=$((2 * i))
        # Add the even number to the sum
        sum=$((sum + even))
        # Increment the counter
        i=$((i + 1))
    done

    echo "The sum of the first $n even numbers is: $sum"
}

# Function to get user input if no argument is provided
get_user_input() {
    read -p "Please enter the number of even numbers to sum: " n
    echo $n
}

# Check if a number is provided as an argument, if not, prompt the user
if [ -z "$1" ]; then
    n=$(get_user_input)
else
    n=$1
fi

# Validate that the input is a positive integer
if ! [[ "$n" =~ ^[0-9]+$ ]]; then
    echo "Error: Please enter a valid positive integer."
    exit 1
fi

# Call the function with the provided or entered argument
sum_even_numbers $n






12. Sum of n odd numbers






#!/bin/bash

# Function to calculate the sum of n odd numbers
sum_of_odd_numbers() {
    n=$1
    sum=0
    count=0
    num=1

    while [ $count -lt $n ]; do
        if [ $((num % 2)) -ne 0 ]; then
            sum=$((sum + num))
            count=$((count + 1))
        fi
        num=$((num + 1))
    done

    echo $sum
}

# Read input from user
read -p "Enter the value of n: " n

# Call function to calculate sum of n odd numbers and print the result
result=$(sum_of_odd_numbers $n)
echo "Sum of the first $n odd numbers is: $result"






13. Sum of n natural numbers






#!/bin/bash

# Function to calculate the sum of n natural numbers
sum_of_natural_numbers() {
    n=$1
    sum=0

    for (( i=1; i<=n; i++ )); do
        sum=$((sum + i))
    done

    echo $sum
}

# Read input from user
read -p "Enter the value of n: " n

# Call function to calculate sum of n natural numbers and print the result
result=$(sum_of_natural_numbers $n)
echo "Sum of the first $n natural numbers is: $result"




14. Factorial




#!/bin/bash

# Function to calculate factorial
factorial() {
    if [ $1 -eq 0 ]; then        # Base case: If the input number is 0, factorial is 1
        echo 1
    else
        echo $(( $1 * $(factorial $(( $1 - 1 ))) ))   # Recursive case: Multiply the number with factorial of (number - 1)
    fi
}

# Read input from user
read -p "Enter a number: " num

# Call factorial function and print the result
echo "Factorial of $num is $(factorial $num)"






15. HCF and LCM

#!/bin/bash

# Function to calculate HCF (GCD) using the Euclidean algorithm
hcf() {
    local a=$1
    local b=$2
    while [ $b -ne 0 ]; do
        local temp=$b
        b=$((a % b))
        a=$temp
    done
    echo $a
}

# Function to calculate LCM using the relationship between HCF and LCM
lcm() {
    local a=$1
    local b=$2
    local gcd=$(hcf $a $b)
    echo $((a * b / gcd))
}

# Read input from user
read -p "Enter the first number: " num1
read -p "Enter the second number: " num2

# Calculate HCF and LCM
hcf_result=$(hcf $num1 $num2)
lcm_result=$(lcm $num1 $num2)

# Print the results
echo "HCF of $num1 and $num2 is: $hcf_result"
echo "LCM of $num1 and $num2 is: $lcm_result"






















///// CPU Scheduling:





1.	FCFS (Non Premptive only)





#include <stdio.h>

int n, Pid[10], AT[10], BT[10], CT[10], TAT[10], WT[10], RT[10], start_time = 0, tTAT = 0, tWT = 0, ATAT = 0, AWT = 0, ART = 0;

void sortProcesses(int n, int AT[], int BT[], int Pid[]) {
    for (int i = 0; i < n - 1; i++) {
        for (int j = i + 1; j < n; j++) {
            if (AT[i] > AT[j]) {
                // swap AT
                int temp = AT[i];
                AT[i] = AT[j];
                AT[j] = temp;

                // swap BT
                temp = BT[i];
                BT[i] = BT[j];
                BT[j] = temp;

                // swap Pid
                temp = Pid[i];
                Pid[i] = Pid[j];
                Pid[j] = temp;
            }
        }
    }
}

int main() {
    printf("Welcome to FCFS Process Scheduling....!!!\n\n");
    printf("Enter the number of processes: ");
    scanf("%d", &n);

    printf("\nEnter the Arrival Time of the Processes\n");
    for (int i = 0; i < n; i++) {
        Pid[i] = i;
        printf("Arrival Time of Process %d: ", i);
        scanf("%d", &AT[i]);
    }

    printf("\nEnter the Burst Time of the Processes\n");
    for (int i = 0; i < n; i++) {
        printf("Burst Time of Process %d: ", i);
        scanf("%d", &BT[i]);
    }

    // Sorting the processes by arrival time
    sortProcesses(n, AT, BT, Pid);

    // Calculate completion times (CT)
    CT[0] = AT[0] + BT[Pid[0]];
    for (int i = 1; i < n; i++) {
        if (AT[i] > CT[i - 1]) {
            CT[i] = AT[i] + BT[Pid[i]];
        } else {
            CT[i] = CT[i - 1] + BT[Pid[i]];
        }
    }

    // Calculate TAT, WT, RT
    for (int i = 0; i < n; i++) {
        TAT[i] = CT[i] - AT[i];
        WT[i] = TAT[i] - BT[Pid[i]];
        if (i == 0) {
            RT[i] = 0;
        } else {
            RT[i] = CT[i - 1] - AT[i];
        }
    }

    // Print the results
    printf("\nPid \t AT \t BT \t CT \t TAT \t WT \t RT\n");
    for (int i = 0; i < n; i++) {
        printf(" %d \t %d \t %d \t %d \t %d \t %d \t %d \n", Pid[i], AT[i], BT[Pid[i]], CT[i], TAT[i], WT[i], RT[i]);
    }

    // Calculate averages
    for (int i = 0; i < n; i++) {
        tTAT += TAT[i];
        tWT += WT[i];
    }

    ATAT = tTAT / n;
    AWT = tWT / n;
    ART = AWT;

    printf("\n\nAverage TAT is: %d", ATAT);
    printf("\n\nAverage WT is: %d", AWT);
    printf("\n\nAverage RT is: %d", ART);

    // Print the execution sequence
    printf("\n\nExecution sequence: ");
    for (int i = 0; i < n; i++) {
        printf("P%d ", Pid[i]);
    }
    printf("\n");

    return 0;
}


4
0 1 5 6 
2 2 3 4 













2.	SJF (Non Preemptive)








#include <stdio.h>
#include <stdlib.h>

struct process {
    int pid;
    int wt;
    int bt;
    int at;
    int tat;
    int start_time;
    int completion_time;
};

int main() {
    int n;

    float avg_tat = 0;
    float avg_wt = 0;

    printf("Enter the number of processes: ");
    scanf("%d", &n);
    int is_completed[n]; // Initialize is_completed array
    int execution_sequence[n]; // Array to store the execution sequence
    struct process p[n]; // An array of structures, not pointers

    for (int j = 0; j < n; j++) {
        is_completed[j] = 0;
    }

    for (int i = 0; i < n; i++) {
        printf("Enter the Pid, Arrival Time, Burst Time for process %d: ", i + 1);
        scanf("%d %d %d", &p[i].pid, &p[i].at, &p[i].bt);
    }

    int current_time = 0;
    int completed = 0;
    int sequence_index = 0; // Index for execution_sequence array

    while (completed != n) {
        int index = -1, min = 999;
        for (int i = 0; i < n; i++) {
            if (p[i].at <= current_time && is_completed[i] == 0) {
                if (p[i].bt < min) {
                    min = p[i].bt;
                    index = i;
                }
                if (p[i].bt == min) {
                    if (p[i].at < p[index].at) {
                        min = p[i].bt;
                        index = i;
                    }
                }
            }
        }
        if (index != -1) {
            p[index].start_time = current_time;
            p[index].completion_time = p[index].start_time + p[index].bt;
            p[index].tat = p[index].completion_time - p[index].at;
            p[index].wt = p[index].tat - p[index].bt;
            completed++;
            is_completed[index] = 1;
            current_time = p[index].completion_time;

            // Store the executed process in the sequence array
            execution_sequence[sequence_index++] = p[index].pid;
        } else {
            current_time++;
        }
    }

    printf("PID\tAT\tBT\tCT\tTAT\tWT\tST\n");
    for (int k = 0; k < n; k++) {
        printf("%d\t%d\t%d\t%d\t%d\t%d\t%d\n", p[k].pid, p[k].at, p[k].bt, p[k].completion_time, p[k].tat, p[k].wt, p[k].start_time);
    }

    // Corrected calculation of averages after all processes complete
    for (int i = 0; i < n; i++) {
        avg_tat += p[i].tat;
        avg_wt += p[i].wt;
    }

    avg_tat /= n;
    avg_wt /= n;

    printf("\nAVG TAT:%f", avg_tat);
    printf("\nAVG WT:%f\n", avg_wt);

    // Display the sequence of processes executed
    printf("Execution Sequence: ");
    for (int i = 0; i < n; i++) {
        printf("%d ", execution_sequence[i]);
    }

    return 0;
}




4
1 1 3
2 2 4
3 1 2
4 4 4








3.	SJF Preemptive







#include <stdio.h>

void sjf(int num) {
    int AT[num], BT[num], WT[num], TAT[num], CT[num], RT[num], current = 0, sj = -1, totalBT = 0;
    float sumWT = 0, sumTAT = 0;
    int sequence[100], seq_index = 0;  // Array to store the execution sequence and index

    for(int i = 0; i < num; i++) {
        printf("Enter the arrival time and burst time for process %d: ", i+1);
        scanf("%d %d", &AT[i], &BT[i]);
        RT[i] = BT[i];
        totalBT += BT[i];
    }

    // Check if the AT is less than or equal to current
    // If yes, execute the process
    // If during the execution of the process, another process of shorter BT is ready, this process will interrupt the current process
    // Will go on till RT[all] = 0

    while(totalBT != 0) {
        sj = -1;
        for(int i = 0; i < num; i++) {
            if(AT[i] <= current && (sj == -1 || RT[sj] > RT[i]) && RT[i] != 0) {
                sj = i;
            }
        }

        if(sj == -1) {
            current++;
            continue;
        }

        totalBT--;
        RT[sj]--;
        sequence[seq_index++] = sj + 1;  // Store the process number in the sequence array
        current++;

        if(RT[sj] == 0) {
            CT[sj] = current;
            TAT[sj] = CT[sj] - AT[sj];
            WT[sj] = TAT[sj] - BT[sj];
        }
    }

    printf("\nProcess | AT | BT | CT | TAT | WT |\n");
    for (int i = 0; i < num; i++) {
        printf("  P%d    | %2d | %2d | %2d | %2d | %2d  |\n", i + 1, AT[i], BT[i], CT[i], TAT[i], WT[i]);
        sumWT  +=  WT[i];
        sumTAT += TAT[i];
    }

    printf("\nSequence of execution: ");
    for (int i = 0; i < seq_index; i++) {
        printf("P%d ", sequence[i]);
    }
    printf("\n");

    printf("\nAvg WT  = %0.3f\n", sumWT / num);
    printf("Avg TAT = %0.3f\n", sumTAT / num);
}

int main() {
    int num;
    printf("Enter the number of processes: ");
    scanf("%d", &num);

    sjf(num);
    return 0;
}



4
0 5
1 3 
2 4 
4 1








4.	Round Robin 




#include <stdio.h>
#include <stdbool.h>

typedef struct {
    int pid;
    int at;
    int bt;
    int rt;
    int ct;
    int wt;
    int tat;
} Process;

void enqueue(Process queue[], int *rear, Process p) {
    queue[++(*rear)] = p;
}

Process dequeue(Process queue[], int *front) {
    return queue[(*front)++];
}

bool isEmpty(int front, int rear) {
    return front > rear;
}

int main() {
    Process processes[] = {
        {1, 0, 5, 5, 0, 0, 0},
        {2, 1, 4, 4, 0, 0, 0},
        {3, 2, 2, 2, 0, 0, 0},
        {4, 4, 1, 1, 0, 0, 0}
    };

    int n = sizeof(processes) / sizeof(processes[0]);
    int timeQuantum = 2;
    int currTime = 0;
    int completedProcesses = 0;

    Process readyQ[100];
    int front = 0, rear = -1;

    Process arrivedProcesses[100];
    for (int i = 0; i < n; i++) {
        arrivedProcesses[i] = processes[i];
    }
    int arrivedCount = n;

    printf("Sequence of Execution:\n");

    while (completedProcesses < n) {
        for (int i = 0; i < arrivedCount; i++) {
            Process p = arrivedProcesses[i];
            if (p.at <= currTime) {
                enqueue(readyQ, &rear, p);
                for (int j = i; j < arrivedCount - 1; j++) {
                    arrivedProcesses[j] = arrivedProcesses[j + 1];
                }
                arrivedCount--;
                i--;
            }
        }

        if (!isEmpty(front, rear)) {
            Process current = dequeue(readyQ, &front);
            printf("Executing Process %d from time %d to ", current.pid, currTime);
            int executionTime = (timeQuantum < current.rt) ? timeQuantum : current.rt;
            currTime += executionTime;
            printf("%d\n", currTime);
            current.rt -= executionTime;

            for (int i = 0; i < arrivedCount; i++) {
                Process p = arrivedProcesses[i];
                if (p.at <= currTime) {
                    enqueue(readyQ, &rear, p);
                    for (int j = i; j < arrivedCount - 1; j++) {
                        arrivedProcesses[j] = arrivedProcesses[j + 1];
                    }
                    arrivedCount--;
                    i--;
                }
            }

            if (current.rt > 0) {
                enqueue(readyQ, &rear, current);
            } else {
                current.ct = currTime;
                current.tat = currTime - current.at;
                current.wt = current.tat - current.bt;
                for (int i = 0; i < n; i++) {
                    if (processes[i].pid == current.pid) {
                        processes[i] = current;
                        break;
                    }
                }
                completedProcesses++;
            }
        } else {
            currTime++;
        }
    }

    printf("\nPID\tAT\tBT\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        Process p = processes[i];
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", p.pid, p.at, p.bt, p.ct, p.tat, p.wt);
    }

    return 0;
}







6.	Priority (Non Preemptive)





#include <stdio.h>
#include <stdlib.h>

struct Process {
    int at;
    int ct;
    int bt;
    int pid;
    int priority;
    int tat;
    int wt;
};

int max(int a, int b) {
    return (a > b) ? a : b;
}

int main() {
    struct Process {
        int at;
        int ct;
        int bt;
        int pid;
        int priority;
        int tat;
        int wt;
    };

    struct Process processes[4] = {
        {0, 0, 4, 1, 1, 0, 0},
        {1, 0, 5, 2, 3, 0, 0},
        {2, 0, 9, 3, 1, 0, 0},
        {5, 0, 8, 4, 2, 0, 0}
    };

    int n = 4;
    int currentTime = 0;
    int completedProcess = 0;

    printf("Execution Sequence:\n");

    while (completedProcess < n) {
        struct Process* highestPriority = NULL;
        for (int i = 0; i < n; i++) {
            if (processes[i].at <= currentTime && processes[i].ct == 0) {
                if (highestPriority == NULL || processes[i].priority < highestPriority->priority) {
                    highestPriority = &processes[i];
                }
            }
        }

        if (highestPriority != NULL) {
            currentTime = max(currentTime, highestPriority->at);
            currentTime += highestPriority->bt;
            highestPriority->ct = currentTime;
            highestPriority->tat = highestPriority->ct - highestPriority->at;
            highestPriority->wt = highestPriority->tat - highestPriority->bt;
            printf("Process %d completed at time %d\n", highestPriority->pid, highestPriority->ct);
            completedProcess++;
        } else {
            currentTime++;
        }
    }

    printf("\nPID\tAT\tBT\tPriority\tCT\tTAT\tWT\n");
    for (int i = 0; i < n; i++) {
        printf("%d\t%d\t%d\t%d\t\t%d\t%d\t%d\n", processes[i].pid, processes[i].at, processes[i].bt, processes[i].priority, processes[i].ct, processes[i].tat, processes[i].wt);
    }

    return 0;
}








8.	Priority (Preemptive)






#include <stdio.h>

void main()
{
    int p;
    printf("Enter number of processes : ");
    scanf("%d", &p);
    int at[p], bt[p], temp[p], ft[p], tat[p], wt[p], visited[p], pp[p], small;
    int count = 0, curTime = 0, totalTime = 0;
    float t = 0, w = 0;
    for (int i = 0; i < p; i++)
    {
        printf("Enter AT of process %d : ", i);
        scanf("%d", &at[i]);
        printf("Enter BT of process %d : ", i);
        scanf("%d", &bt[i]);
        printf("Enter prioirty of process %d : ", i);
        scanf("%d", &pp[i]);
        printf("\n");
        totalTime += bt[i];
        temp[i] = bt[i];
        visited[i] = 0;
    }

    small = at[0];
    for (int i = 0; i < p; i++)
    {
        if (at[i] < small)
        {
            small = at[i];
        }
    }

    curTime = small;
    totalTime += small;

    while (curTime < totalTime)
    {
        for (int i = 0; i < p; i++)
        {
            if (visited[i] == 0 && at[i] <= curTime)
            {
                small = i;
                break;
            }
        }

        for (int i = 0; i < p; i++)
        {
            if (visited[i] == 0 && at[i] <= curTime && pp[i] < pp[small])
            {
                small = i;
            }
            else if (visited[i] == 0 && at[i] <= curTime && pp[i] == pp[small] && at[i] < at[small])
            {
                small = i;
            }
        }

        curTime++;
        bt[small]--;
        if (bt[small] == 0)
        {
            ft[small] = curTime;
            visited[small] = 1;
        }
    }

    printf("\nprocess\tAT\tBT\tFT\tTAT\tWT\n");
    for (int i = 0; i < p; i++)
    {
        tat[i] = ft[i] - at[i];
        wt[i] = tat[i] - temp[i];
        t += tat[i];
        w += wt[i];
        printf("%d\t%d\t%d\t%d\t%d\t%d\n", i, at[i], temp[i], ft[i], tat[i], wt[i]);
    }

    printf("\nAvg. TAT : %.2f", t / p);
    printf("\nAvg. WT : %.2f", w / p);
}




4
 0 5 10
 1 4 20
 2 2 30
 4 1 40










/////Deadlock detection







#include<stdio.h>
static int mark[20];
int i,j,np,nr;
 
int main()
{
int alloc[10][10],request[10][10],avail[10],r[10],w[10];
 
printf("\nEnter the no of process: ");
scanf("%d",&np);
printf("\nEnter the no of resources: ");
scanf("%d",&nr);
for(i=0;i<nr;i++)
{
printf("\nTotal Amount of the Resource R%d: ",i+1);
scanf("%d",&r[i]);
}



printf("\nEnter the request matrix:");
 
for(i=0;i<np;i++)
for(j=0;j<nr;j++)
scanf("%d",&request[i][j]);
 
printf("\nEnter the allocation matrix:");
for(i=0;i<np;i++)
for(j=0;j<nr;j++)
scanf("%d",&alloc[i][j]);
/*Available Resource calculation*/
for(j=0;j<nr;j++)
{
avail[j]=r[j];
for(i=0;i<np;i++)
{
avail[j]-=alloc[i][j];
 
}
}
 
//marking processes with zero allocation
 
for(i=0;i<np;i++)
{
int count=0;
 for(j=0;j<nr;j++)
   {
      if(alloc[i][j]==0)
        count++;
      else
        break;
    }
 if(count==nr)
 mark[i]=1;
}
// initialize W with avail
 
for(j=0;j<nr;j++)
    w[j]=avail[j];
 
//mark processes with request less than or equal to W
for(i=0;i<np;i++)
{
int canbeprocessed=0;
 if(mark[i]!=1)
{
   for(j=0;j<nr;j++)
    {
      if(request[i][j]<=w[j])
        canbeprocessed=1;
      else
         {
         canbeprocessed=0;
         break;
          }
     }
if(canbeprocessed)
{
mark[i]=1;
 
for(j=0;j<nr;j++)
w[j]+=alloc[i][j];
}
}
}
 
//checking for unmarked processes
int deadlock=0;
for(i=0;i<np;i++)
if(mark[i]!=1)
deadlock=1;
 

if(deadlock)
printf("\n Deadlock detected");
else
printf("\n No Deadlock possible");
 
return 0;
}



3
4
10
5
7
3
1 0 2 1
1 0 3 3
1 2 1 0
1 0 2 1
0 0 3 3
1 2 1 0








///// Banker’s Algorithm:







#include <stdio.h>
#include <stdbool.h>

#define MAX_PROCESSES 10
#define MAX_RESOURCES 10

int no_of_processes, no_of_resources;
int available[MAX_RESOURCES];
int max_need[MAX_PROCESSES][MAX_RESOURCES];
int allocated[MAX_PROCESSES][MAX_RESOURCES];
int need[MAX_PROCESSES][MAX_RESOURCES];
bool finish[MAX_PROCESSES];

// Function to check if a process can be safely executed
bool isSafe(int process) {
    for (int i = 0; i < no_of_resources; i++) {
        if (need[process][i] > available[i])
            return false;
    }
    return true;
}

int main() {
    printf("**** BANKER'S ALGORITHM ****\n\n");

    // Input the number of processes and resources
    printf("Enter the number of processes: ");
    scanf("%d", &no_of_processes);
    printf("Enter the number of resources: ");
    scanf("%d", &no_of_resources);

    // Input the maximum resource needs for each process
    printf("Enter the maximum resource needs for each process:\n");
    for (int i = 0; i < no_of_processes; i++) {
        printf("Process %d: ", i);
        for (int j = 0; j < no_of_resources; j++) {
            scanf("%d", &max_need[i][j]);
        }
        finish[i] = false;
    }

    // Input the allocated resources for each process
    printf("Enter the allocated resources for each process:\n");
    for (int i = 0; i < no_of_processes; i++) {
        printf("Process %d: ", i);
        for (int j = 0; j < no_of_resources; j++) {
            scanf("%d", &allocated[i][j]);
            need[i][j] = max_need[i][j] - allocated[i][j];
        }
    }

    // Input the available resources
    printf("Enter the available resources: ");
    for (int i = 0; i < no_of_resources; i++) {
        scanf("%d", &available[i]);
    }

    // Display the contents of maximum needs, allocated resources, and needed resources in a tabular format
    printf("\nResource Allocation Table:\n");
    printf("Process | Maximum  | Allocated | Needed  |\n");
    printf("------------------------------------------\n");
    for (int i = 0; i < no_of_processes; i++) {
        printf("P%d      | ", i);
        for (int j = 0; j < no_of_resources; j++) {
            printf("%d ", max_need[i][j]);
        }
        printf("| ");
        for (int j = 0; j < no_of_resources; j++) {
            printf("%d ", allocated[i][j]);
        }
        printf("| ");
        for (int j = 0; j < no_of_resources; j++) {
            printf("%d ", need[i][j]);
        }
        printf("\n");
    }

    // Check for a safe sequence
    bool safe = true;
    int safe_sequence[MAX_PROCESSES];
    int sequence_index = 0;

    for (int count = 0; count < no_of_processes; count++) {
        bool found = false;
        for (int i = 0; i < no_of_processes; i++) {
            if (!finish[i] && isSafe(i)) {
                // Mark this process as safe and simulate its execution
                for (int j = 0; j < no_of_resources; j++) {
                    available[j] += allocated[i][j];
                }
                safe_sequence[sequence_index++] = i;
                finish[i] = true;
                found = true;
                break;
            }
        }
        if (!found) {
            safe = false;
            break;
        }
    }

    if (safe) {
        // If the safe sequence is complete, print it
        printf("\nSystem is in a safe state.\n");
        printf("Safe sequence: ");
        for (int i = 0; i < sequence_index; i++) {
            printf("P%d ", safe_sequence[i]);
        }
        printf("\n");
    } else {
        // The system is in an unsafe state
        printf("\nSystem is in an unsafe state. Deadlock detected.\n");
        printf("Processes involved in the deadlock: ");
        for (int i = 0; i < no_of_processes; i++) {
            if (!finish[i]) {
                printf("P%d ", i);
            }
        }
        printf("\n");
    }

    return 0;
}




5
3
7 5 3 
3 2 2 
9 0 2
4 2 2 
5 3 3 
0 1 0
2 0 0
3 0 2
2 1 1
0 0 2
3 3 2















///// Disk Scheduling:







1.	Scan:




#include<stdio.h>
#include<stdlib.h>
#include<math.h>

void sort(int req[], int no_req)
{
    for(int i = 0; i < no_req-1; i++)
    {
        for(int j = 0; j < no_req-i-1; j++)
        {
            if (req[j] > req[j+1]) 
            {
                int temp = req[j];
                req[j] = req[j+1];
                req[j+1] = temp;
            }
        }
    }
}

void elevator(int req[], int no_req, int head, int tracks)
{
    int distarray[100], s=0, index = -1, c = 0, flag = 0, seq[no_req + 1];
    float s1;

    for(int i = 0; i < no_req; i++)
    {
        if(req[i] > head)
        {
            index = i;
            seq[c] = req[i];
            c++;
            flag = 1;
        }
    }

    seq[c] = tracks - 1;

    for(int j = index; j >= 0; j--)
    {
        if(head > req[j])
        {
            seq[c+1] = req[j];
            c++;
        }
    }

    printf("The sequence is: ");
    for(int i = 0; i < no_req+1; i++)
    {
        printf("%d ", seq[i]);
    }
    
    for(int i = 0; i < no_req+1; i++)
    {
        int dist = abs(head - seq[i]);
        distarray[i] = dist;
        head = seq[i];
    }

    printf("\nDIST: ");
    for(int i = 0; i < no_req+1; i++)
    {
        printf("%d ", distarray[i]);
    }

    for(int i = 0; i < no_req+1; i++)
    {
        s = s + distarray[i];
    }
    s1 = (float)s/no_req;

    printf("\nThe total seek time is: %d\n", s);
    printf("The avg seek time is: %.2f\n", s1);
}

int main()
{
    int tracks;
    printf("Enter the number of tracks: ");
    scanf("%d", &tracks);

    int no_req;
    printf("Enter the number of requests: ");
    scanf("%d", &no_req);

    int req[no_req];
    printf("Enter the requests..");
    for(int i = 0; i < no_req; i++)
    {
        printf("Request %d: ", i+1);
        scanf("%d", &req[i]);
    }

    sort(req, no_req);

    int head;
    printf("Enter the current head: ");
    scanf("%d", &head);

    elevator(req, no_req, head, tracks);

    return 0;
}


200
7
82 170 43 140 24 16 190
50






2.	CSCAN:




#include <stdio.h>
#include <stdlib.h>
#include <math.h>

void sort(int req[], int no_req) {
    for(int i = 0; i < no_req-1; i++) {
        for(int j = 0; j < no_req-i-1; j++) {
            if (req[j] > req[j+1]) {
                int temp = req[j];
                req[j] = req[j+1];
                req[j+1] = temp;
            }
        }
    }
}

void cscan(int req[], int no_req, int head, int tracks) {
    int distarray[100], s = 0, c = 0, index = -1;
    int seq[100];  // Array to store the sequence of requests

    sort(req, no_req);

    // Find the index where the head is located in the request array
    for (index = 0; index < no_req; index++) {
        if (head < req[index]) {
            break;
        }
    }

    // Handle the requests from head to the end of the disk
    for (int i = index; i < no_req; i++) {
        distarray[c] = abs(head - req[i]);
        s += distarray[c];
        head = req[i];
        seq[c] = head;  // Store the sequence
        c++;
    }

    // Move the head to the end of the disk
    distarray[c] = abs(head - (tracks - 1));
    s += distarray[c];
    head = tracks - 1;
    seq[c] = head;  // Store the end of the disk
    c++;

    // Move the head to the beginning of the disk
    distarray[c] = abs(head - 0);
    s += distarray[c];
    head = 0;
    seq[c] = head;  // Store the beginning of the disk
    c++;

    // Handle the requests from the beginning of the disk to the head
    for (int i = 0; i < index; i++) {
        distarray[c] = abs(head - req[i]);
        s += distarray[c];
        head = req[i];
        seq[c] = head;  // Store the sequence
        c++;
    }

    printf("\nThe sequence is: ");
    for (int i = 0; i < c; i++) {
        printf("%d ", seq[i]);
    }

    printf("\nDIST: ");
    for (int i = 0; i < c; i++) {
        printf("%d ", distarray[i]);
    }

    printf("\nThe total seek time is: %d\n", s);
    printf("The avg seek time is: %.2f\n", (float)s / no_req);
}

int main() {
    int tracks;
    printf("Enter the number of tracks: ");
    scanf("%d", &tracks);

    int no_req;
    printf("Enter the number of requests: ");
    scanf("%d", &no_req);

    int req[no_req];
    printf("Enter the requests:\n");
    for(int i = 0; i < no_req; i++) {
        printf("Request %d: ", i+1);
        scanf("%d", &req[i]);
    }

    int head;
    printf("Enter the current head: ");
    scanf("%d", &head);

    cscan(req, no_req, head, tracks);

    return 0;
}


200
7
82 170 43 140 24 16 190
50






3.	FCFS:





#include<stdio.h>
#include<stdlib.h>
#include<math.h>

int main()
{
    int n;
    float seek_time=0;

    printf("enter the number of requests :");
    scanf("%d",&n);
    int req[n];
    int store[n];

    printf("start entering...");
    for(int i=0;i<n;i++)
    {   
        printf("\nenter reqest %d: ",i+1);
        scanf("%d",&req[i]);    
    }

    int head;
    printf("enter the head position : ");
    scanf("%d",&head);

    for(int i=0;i<n;i++)
    {   
        store[i] = abs(head-req[i]);
        seek_time = seek_time + store[i];
        head = req[i];
        printf("%d ",store[i]);
    }

    printf("\nTotal seek time: %f",seek_time);
    printf("\n");
    printf("Average seek time: %f",seek_time / n);
}




200
7
82 170 43 140 24 16 190
50





4.	SSTF:





#include <stdio.h>
#include <stdlib.h>

int main()
{
    int n, head;
    printf("enter the number of requests: ");
    scanf("%d", &n);
    int req[n], store[n], order[n];

    printf("Start entering..\n");
    for (int i = 0; i < n; i++)
    {
        scanf("%d", &req[i]);
        order[i] = -1;  // Initialize order array to -1
    }
    printf("enter the head pointer location  :");
    scanf("%d", &head);

    for (int i = 0; i < n; i++)
    {
        int min = 999;
        for (int j = 0; j < n; j++)
        {
            if (req[j] != 0)
            {
                int dist = abs(head - req[j]);
                if (dist < min)
                {
                    min = dist;
                    store[i] = dist;
                    order[i] = req[j];  // Store the visited request
                }
            }
        }
        for (int k = 0; k < n; k++)
        {
            if (req[k] != 0)
            {
                int dist = abs(head - req[k]);
                if (min == dist)
                {
                    head = req[k];
                    req[k] = 0;
                    break;
                }
            }
        }
    }

    float seek_time = 0;
    printf("seek sequence:");
    for (int i = 0; i < n; i++)
    {
        printf("%d ", store[i]);
        seek_time = seek_time + store[i];
    }

    printf("\nOrder of requests visited:");
    for (int i = 0; i < n; i++)
    {
        if (order[i] != -1)
        {
            printf(" %d", order[i]);
        }
    }

    printf("\n seek time: %f ", (seek_time));
    printf("\n");
    printf("\nAvg seek time: %f ", (seek_time / n));

    return 0;
}



200
7
82 170 43 140 24 16 190
50















///// Page Replacement Algorithms:






1.	FIFO:



#include <stdio.h>

void fifo(int numOfFrames, int numOfPages, int pages[])
{
    int frame[numOfFrames];
    for (int i = 0; i < numOfFrames; i++)
    {
        frame[i] = -1;
    }

    int hit = 0, miss = 0, index = -1;
    for (int i = 0; i < numOfPages; i++)
    {
        int flag = 0;
        for (int j = 0; j < numOfFrames; j++)
        {
            if (frame[j] == pages[i])
            {
                flag = 1;
                break;
            }
        }

        if (flag)
        {
            printf("\nSymbol: %d  Frame: ", pages[i]);
            for (int k = 0; k < numOfFrames; k++)
            {
                printf("%d ", frame[k]);
            }
            hit++;
        }
        else
        {
            index = (index + 1) % numOfFrames;
            frame[index] = pages[i];
            miss++;
            printf("\nSymbol: %d  Frame: ", pages[i]);
            for (int k = 0; k < numOfFrames; k++)
            {
                printf("%d ", frame[k]);
            }
        }
    }
    printf("\n\nPage hits: %d", hit);
    printf("\nPage misses: %d", miss);
}

void main()
{
    int p, f;
    printf("Enter number of frames : ");
    scanf("%d", &f);
    printf("Enter number of pages : ");
    scanf("%d", &p);

    int pages[p];
    for (int i = 0; i < p; i++)
    {
        printf("Enter page : ");
        scanf("%d", &pages[i]);
    }
    fifo(f, p, pages);
}


3
12
0 4 1 4 2 4 3 4 0 4 1 4




2.	LRU:




#include <stdio.h>

void lur(int numOfFrames, int numOfPages, int pages[])
{
    int position;
    int frame[numOfFrames];
    for (int i = 0; i < numOfFrames; i++)
    {
        frame[i] = -1;
    }

    int hit = 0, miss = 0;

    for (int i = 0; i < numOfPages; i++)
    {
        int flag1 = 0, flag2 = 0;

        for (int j = 0; j < numOfFrames; j++)
        {
            if (frame[j] == pages[i])
            {
                hit++;
                flag1 = flag2 = 1;
                break;
            }
        }
        if (flag1 == 0)
        {
            for (int j = 0; j < numOfFrames; j++)
            {
                if (frame[j] == -1)
                {
                    frame[j] = pages[i];
                    miss++;
                    flag2 = 1;
                    break;
                }
            }
        }
        if (flag2 == 0)
        {
            int flag3 = 0;
            int temp[numOfFrames];
            for (int j = 0; j < numOfFrames; j++)
            {
                temp[j] = -1;
                for (int k = i - 1; k >= 0; k--)
                {
                    if (frame[j] == pages[k])
                    {
                        temp[j] = k;
                        break;
                    }
                }
            }

            for (int j = 0; j < numOfFrames; j++)
            {
                if (temp[j] == -1)
                {
                    position = j;
                    flag3 = 1;
                    break;
                }
            }

            if (flag3 == 0)
            {
                int min = temp[0];
                position = 0;
                for (int j = 1; j < numOfFrames; j++)
                {
                    if (temp[j] < min)
                    {
                        min = temp[j];
                        position = j;
                    }
                }
            }
            frame[position] = pages[i];
            miss++;
        }
        printf("\nSymbol: %d  Frame: ", pages[i]);
        for (int j = 0; j < numOfFrames; j++)
        {
            printf("%d ", frame[j]);
        }
    }
    printf("\n\nPage hits: %d", hit);
    printf("\nPage misses: %d", miss);
}

void main()
{
    int p, f;
    printf("Enter number of frames : ");
    scanf("%d", &f);
    printf("Enter number of pages : ");
    scanf("%d", &p);

    int pages[p];
    for (int i = 0; i < p; i++)
    {
        printf("Enter page : ");
        scanf("%d", &pages[i]);
    }
    lur(f, p, pages);
}

3
12
7 0 1 2 0 3 0 4 2 3 0 3



3.	Optimal:



#include <stdio.h>

void optimal(int numOfFrames, int numOfPages, int pages[])
{
    int position;
    int frame[numOfFrames];
    for (int i = 0; i < numOfFrames; i++)
    {
        frame[i] = -1;
    }

    int hit = 0, miss = 0;

    for (int i = 0; i < numOfPages; i++)
    {
        int flag1 = 0, flag2 = 0;
        for (int j = 0; j < numOfFrames; j++)
        {
            if (frame[j] == pages[i])
            {
                flag1 = flag2 = 1;
                hit++;
                break;
            }
        }
        if (flag1 == 0)
        {
            for (int j = 0; j < numOfFrames; j++)
            {
                if (frame[j] == -1)
                {
                    miss++;
                    frame[j] = pages[i];
                    flag2 = 1;
                    break;
                }
            }
        }
        if (flag2 == 0)
        {
            int flag3 = 0;
            int temp[numOfFrames];
            for (int j = 0; j < numOfFrames; j++)
            {
                temp[j] = -1;
                for (int k = i + 1; k < numOfPages; k++)
                {
                    if (frame[j] == pages[k])
                    {
                        temp[j] = k;
                        break;
                    }
                }
            }
            for (int j = 0; j < numOfFrames; j++)
            {
                if (temp[j] == -1)
                {
                    position = j;
                    flag3 = 1;
                    break;
                }
            }

            if (flag3 == 0)
            {
                int max = temp[0];
                position = 0;
                for (int j = 1; j < numOfFrames; j++)
                {
                    if (temp[j] > max)
                    {
                        max = temp[j];
                        position = j;
                    }
                }
            }
            frame[position] = pages[i];
            miss++;
        }
        printf("\nSymbol: %d  Frame: ", pages[i]);
        for (int j = 0; j < numOfFrames; j++)
        {
            printf("%d ", frame[j]);
        }
    }
    printf("\n\nPage hits: %d", hit);
    printf("\nPage misses: %d", miss);
}

void main()
{
    int p, f;
    printf("Enter number of frames : ");
    scanf("%d", &f);
    printf("Enter number of pages : ");
    scanf("%d", &p);

    int pages[p];
    for (int i = 0; i < p; i++)
    {
        printf("Enter page : ");
        scanf("%d", &pages[i]);
    }
    optimal(f, p, pages);
}


3
12 
0 4 1 4 2 4 3 4 0 4 1 4





4. Second Chance / Clock:




#include <stdio.h>
#include <stdbool.h>

#define MAX_FRAMES 3

// Function to find the index of the least recently used frame
int findLRU(int lru[]) {
    int min = lru[0];
    int index = 0;
    for (int i = 1; i < MAX_FRAMES; i++) {
        if (lru[i] < min) {
            min = lru[i];
            index = i;
        }
    }
    return index;
}

// Function to perform Least Recently Used (LRU) page replacement algorithm
int pageFaultsLRU(int pages[], int n) {
    int frames[MAX_FRAMES];
    int pageFaults = 0;
    int lru[MAX_FRAMES] = {0};

    for (int i = 0; i < MAX_FRAMES; i++) {
        frames[i] = -1; // Initialize all frames to -1 (empty)
    }

    for (int i = 0; i < n; i++) {
        bool pageExists = false;
        // Check if page is already in frames
        for (int j = 0; j < MAX_FRAMES; j++) {
            if (frames[j] == pages[i]) {
                pageExists = true;
                // Update LRU value for the current frame
                lru[j] = i + 1; // Timestamp is the index of the page reference + 1
                break;
            }
        }

        if (!pageExists) {
            pageFaults++;
            // Find the frame with the lowest LRU value
            int replaceIndex = findLRU(lru);
            // Replace the page in the frame with the lowest LRU value
            frames[replaceIndex] = pages[i];
            // Update LRU value for the current frame
            lru[replaceIndex] = i + 1; // Timestamp is the index of the page reference + 1
        }
    }

    return pageFaults;
}

// Function to perform Second Chance (Clock) page replacement algorithm
int pageFaultsSecondChance(int pages[], int n) {
    int frames[MAX_FRAMES];
    bool referenceBit[MAX_FRAMES];
    int pageFaults = 0;
    int hand = 0; // Hand points to the next frame to check for replacement

    for (int i = 0; i < MAX_FRAMES; i++) {
        frames[i] = -1; // Initialize all frames to -1 (empty)
        referenceBit[i] = false; // Initialize all reference bits to false
    }

    for (int i = 0; i < n; i++) {
        bool pageExists = false;
        // Check if page is already in frames
        for (int j = 0; j < MAX_FRAMES; j++) {
            if (frames[j] == pages[i]) {
                pageExists = true;
                referenceBit[j] = true; // Set the reference bit to true
                break;
            }
        }

        if (!pageExists) {
            pageFaults++;
            while (true) {
                if (!referenceBit[hand]) {
                    // Replace the frame pointed by the hand
                    frames[hand] = pages[i];
                    referenceBit[hand] = true; // Set the reference bit to true
                    hand = (hand + 1) % MAX_FRAMES; // Move the hand to the next frame
                    break;
                } else {
                    referenceBit[hand] = false; // Reset the reference bit to false
                    hand = (hand + 1) % MAX_FRAMES; // Move the hand to the next frame
                }
            }
        }
    }

    return pageFaults;
}

int main() {
    int pages[] = {7, 1, 0, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1};
    int n = sizeof(pages) / sizeof(pages[0]);

    int pageFaultsLRUVal = pageFaultsLRU(pages, n);
    printf("Total number of page faults using LRU: %d\n", pageFaultsLRUVal);

    int pageFaultsSecondChanceVal = pageFaultsSecondChance(pages, n);
    printf("Total number of page faults using Second Chance: %d\n", pageFaultsSecondChanceVal);

    return 0;
}







///// Process Synchronization





1.	Producer Consumer

// C program for the above approach
#include <stdio.h>
#include <stdlib.h>

// Initialize a mutex to 1
int mutex = 1;

// Number of full slots as 0
int full = 0;

// Number of empty slots as size
// of buffer
int empty = 10, x = 0;

// Function to produce an item and
// add it to the buffer
void producer()
{
    // Decrease mutex value by 1
    --mutex;

    // Increase the number of full
    // slots by 1
    ++full;

    // Decrease the number of empty
    // slots by 1
    --empty;

    // Item produced
    x++;
    printf("\nProducer produces"
           "item %d",
           x);

    // Increase mutex value by 1
    ++mutex;
}

// Function to consume an item and
// remove it from buffer
void consumer()
{
    // Decrease mutex value by 1
    --mutex;

    // Decrease the number of full
    // slots by 1
    --full;

    // Increase the number of empty
    // slots by 1
    ++empty;
    printf("\nConsumer consumes "
           "item %d",
           x);
    x--;

    // Increase mutex value by 1
    ++mutex;
}

// Driver Code
int main()
{
    int n, i;
    printf("\n1. Press 1 for Producer"
           "\n2. Press 2 for Consumer"
           "\n3. Press 3 for Exit");

// Using '#pragma omp parallel for'
// can  give wrong value due to
// synchronization issues.

// 'critical' specifies that code is
// executed by only one thread at a
// time i.e., only one thread enters
// the critical section at a given time
//#pragma omp critical

    for (i = 1; i > 0; i++) {

        printf("\nEnter your choice:");
        scanf("%d", &n);

        // Switch Cases
        switch (n) {
        case 1:

            // If mutex is 1 and empty
            // is non-zero, then it is
            // possible to produce
            if ((mutex == 1)
                && (empty != 0)) {
                producer();
            }

            // Otherwise, print buffer
            // is full
            else {
                printf("Buffer is full!");
            }
            break;

        case 2:

            // If mutex is 1 and full
            // is non-zero, then it is
            // possible to consume
            if ((mutex == 1)
                && (full != 0)) {
                consumer();
            }

            // Otherwise, print Buffer
            // is empty
            else {
                printf("Buffer is empty!");
            }
            break;

        // Exit Condition
        case 3:
            exit(0);
            break;
        }
    }
}


2.Reader Writer

#include<semaphore.h>
#include<stdio.h>
#include<stdlib.h>
#include<unistd.h>
#include<pthread.h>
#include<unistd.h>

sem_t x,y;
pthread_t tid;
pthread_t writerthreads[100],readerthreads[100];
int readercount = 0;

void *reader(void* param)
{
    sem_wait(&x);
    readercount++;
    if(readercount==1)
        sem_wait(&y);
    sem_post(&x);
    printf("%d reader is inside\n",readercount);
    usleep(3);
    sem_wait(&x);
    readercount--;
    if(readercount==0)
    {
        sem_post(&y);
    }
    sem_post(&x);
    printf("%d Reader is leaving\n",readercount+1);
    return NULL;
}

void *writer(void* param)
{
    printf("Writer is trying to enter\n");
    sem_wait(&y);
    printf("Writer has entered\n");
    sem_post(&y);
    printf("Writer is leaving\n");
    return NULL;
}

int main()
{
    int n2,i;
    printf("Enter the number of readers:");
    scanf("%d",&n2);
    printf("\n");
    int n1[n2];
    sem_init(&x,0,1);
    sem_init(&y,0,1);
    for(i=0;i<n2;i++)
    {
        pthread_create(&writerthreads[i],NULL,reader,NULL);
        pthread_create(&readerthreads[i],NULL,writer,NULL);
    }
    for(i=0;i<n2;i++)
    {
        pthread_join(writerthreads[i],NULL);
        pthread_join(readerthreads[i],NULL);
    }

}


3.Dining Philosopher

#include <pthread.h>
#include <semaphore.h>
#include <stdio.h>
#include <unistd.h>

#define N 5
#define THINKING 2
#define HUNGRY 1
#define EATING 0
#define LEFT (phnum + 4) % N
#define RIGHT (phnum + 1) % N

int state[N];
int phil[N] = { 0, 1, 2, 3, 4 };

sem_t mutex;
sem_t S[N];

void test(int phnum)
{
    if (state[phnum] == HUNGRY
        && state[LEFT] != EATING
        && state[RIGHT] != EATING) {
        // state that eating
        state[phnum] = EATING;

        sleep(2);

        printf("Philosopher %d takes fork %d and %d\n",
                      phnum + 1, LEFT + 1, phnum + 1);

        printf("Philosopher %d is Eating\n", phnum + 1);

        // sem_post(&S[phnum]) has no effect
        // during takefork
        // used to wake up hungry philosophers
        // during putfork
        sem_post(&S[phnum]);
    }
}

// take up chopsticks
void take_fork(int phnum)
{

    sem_wait(&mutex);

    // state that hungry
    state[phnum] = HUNGRY;

    printf("Philosopher %d is Hungry\n", phnum + 1);

    // eat if neighbours are not eating
    test(phnum);

    sem_post(&mutex);

    // if unable to eat wait to be signalled
    sem_wait(&S[phnum]);

    sleep(1);
}

// put down chopsticks
void put_fork(int phnum)
{

    sem_wait(&mutex);

    // state that thinking
    state[phnum] = THINKING;

    printf("Philosopher %d putting fork %d and %d down\n",
           phnum + 1, LEFT + 1, phnum + 1);
    printf("Philosopher %d is thinking\n", phnum + 1);

    test(LEFT);
    test(RIGHT);

    sem_post(&mutex);
}

void* philosopher(void* num)
{

    while (1) {

        int* i = num;

        sleep(1);

        take_fork(*i);

        sleep(0);

        put_fork(*i);
    }
}

int main()
{

    int i;
    pthread_t thread_id[N];

    // initialize the semaphores
    sem_init(&mutex, 0, 1);

    for (i = 0; i < N; i++)

        sem_init(&S[i], 0, 0);

    for (i = 0; i < N; i++) {

        // create philosopher processes
        pthread_create(&thread_id[i], NULL,
                       philosopher, &phil[i]);

        printf("Philosopher %d is thinking\n", i + 1);
    }

    for (i = 0; i < N; i++)

        pthread_join(thread_id[i], NULL);
}









///// Java Synchronization








1. Prod Cons:




package OsJava.sync;

import java.util.concurrent.Semaphore;

class ProducerConsumer {
    static final int BUFFER_SIZE = 5;
    static Semaphore mutex = new Semaphore(1);
    static Semaphore full = new Semaphore(0);
    static Semaphore empty = new Semaphore(BUFFER_SIZE);

    static class Producer extends Thread {
        public void run() {
            for (int i = 0; i < 5; i++) {
                try {
                    empty.acquire();
                    mutex.acquire();
                    System.out.println("Producer produced item " + i);
                    mutex.release();
                    full.release();
                    Thread.sleep(3000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Consumer extends Thread {
        public void run() {
            for (int i = 0; i < 5; i++) {
                try {
                    full.acquire();
                    mutex.acquire();
                    System.out.println("Consumer consumed item " + i);
                    mutex.release();
                    empty.release();
                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        Producer producer = new Producer();
        Consumer consumer = new Consumer();
        producer.start();
        consumer.start();
    }
}







2. Reader Writer






package OsJava.sync;

import java.util.concurrent.Semaphore;

class ReaderWriter {
    static Semaphore mutex = new Semaphore(1);
    static Semaphore rw_mutex = new Semaphore(1);
    static int readers_count = 0;
    static volatile boolean running = true;

    static class Reader extends Thread {
        int readerID;

        Reader(int readerID) {
            this.readerID = readerID;
        }

        public void run() {
            while (running) {
                try {
                    mutex.acquire();
                    readers_count++;
                    if (readers_count == 1) {
                        rw_mutex.acquire();
                    }
                    mutex.release();

                    System.out.println("Reader " + readerID + " is reading.");

                    mutex.acquire();
                    readers_count--;
                    if (readers_count == 0) {
                        rw_mutex.release();
                    }
                    mutex.release();

                    Thread.sleep(1000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    static class Writer extends Thread {
        int writerID;

        Writer(int writerID) {
            this.writerID = writerID;
        }

        public void run() {
            while (running) {
                try {
                    rw_mutex.acquire();

                    System.out.println("Writer " + writerID + " is writing.");

                    rw_mutex.release();

                    Thread.sleep(2000);
                } catch (InterruptedException e) {
                    e.printStackTrace();
                }
            }
        }
    }

    public static void main(String[] args) {
        final int NUM_READERS = 5;
        final int NUM_WRITERS = 2;

        Reader[] readers = new Reader[NUM_READERS];
        Writer[] writers = new Writer[NUM_WRITERS];

        for (int i = 0; i < NUM_READERS; i++) {
            readers[i] = new Reader(i + 1);
            readers[i].start();
        }

        for (int i = 0; i < NUM_WRITERS; i++) {
            writers[i] = new Writer(i + 1);
            writers[i].start();
        }

        try {
            Thread.sleep(3000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        running = false;

        for (Reader reader : readers) {
            try {
                reader.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
        for (Writer writer : writers) {
            try {
                writer.join();
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}







3. Dining Philosopher






package OsJava.sync;

import java.util.concurrent.Semaphore;

class DiningPhilosopher {
    static final int NUM_PHILOSOPHERS = 5;
    static Semaphore[] forks = new Semaphore[NUM_PHILOSOPHERS];
    static Semaphore mutex = new Semaphore(1);

    static class Philosopher extends Thread {
        int id;
        Semaphore leftFork;
        Semaphore rightFork;

        Philosopher(int id, Semaphore leftFork, Semaphore rightFork) {
            this.id = id;
            this.leftFork = leftFork;
            this.rightFork = rightFork;
        }

        void think() throws InterruptedException {
            System.out.println("Philosopher " + id + " is thinking.");
            Thread.sleep(3000);
        }

        void eat() throws InterruptedException {
            System.out.println("Philosopher " + id + " is eating.");
            Thread.sleep(3000);
        }

        @Override
        public void run() {
            try {
                while (true) {
                    think();
                    mutex.acquire();
                    leftFork.acquire();
                    rightFork.acquire();
                    eat();
                    rightFork.release();
                    leftFork.release();
                    mutex.release();
                }
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
            forks[i] = new Semaphore(1);
        }

        Philosopher[] philosophers = new Philosopher[NUM_PHILOSOPHERS];
        for (int i = 0; i < NUM_PHILOSOPHERS; i++) {
            philosophers[i] = new Philosopher(i, forks[i], forks[(i + 1) % NUM_PHILOSOPHERS]);
            philosophers[i].start();
        }
    }
}









////// Memory management







1. First Fit






#include <stdio.h>

void firstfit(int m, int n, int block[], int process[]) {
    int allocation[n];
    for (int i = 0; i < n; i++) {
        allocation[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            if (block[j] >= process[i]) {
                allocation[i] = j;
                block[j] -= process[i];
                break;
            }
        }
    }

    printf("\nProcess No.\tProcess Size\tBlock no.\n");
    for (int i = 0; i < n; i++) {
        printf(" %d\t\t", i + 1);
        printf("%d\t\t", process[i]);
        if (allocation[i] != -1) {
            printf("%d", allocation[i] + 1);
        } else {
            printf("Not Allocated");
        }
        printf("\n");
    }
}

int main() {
    int m, n;
    printf("Enter number of blocks: ");
    scanf("%d", &m);
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int block[m];
    int process[n];

    for (int i = 0; i < m; i++) {
        printf("Enter size of block: ");
        scanf("%d", &block[i]);
    }

    for (int i = 0; i < n; i++) {
        printf("Enter size of process: ");
        scanf("%d", &process[i]);
    }

    firstfit(m, n, block, process);

    return 0;
}


5
4
100 500 200 300 600
212 417 112 426








2. Best Fit




#include <stdio.h>

void bestFit(int m, int n, int blockSize[], int processSize[])
{
    int allocated[n];
    for (int i = 0; i < n; i++)
    {
        allocated[i] = -1;
    }

    for (int i = 0; i < n; i++)
    {
        int bestIndex = -1;

        for (int j = 0; j < m; j++)
        {
            if (blockSize[j] >= processSize[i])
            {
                if (bestIndex == -1)
                {
                    bestIndex = j;
                }
                else if (blockSize[bestIndex] > blockSize[j])
                {
                    bestIndex = j;
                }
            }
        }

        if (bestIndex != -1)
        {
            allocated[i] = bestIndex;
            blockSize[bestIndex] -= processSize[i];
        }
    }

    printf("\nProcess No.\tProcess Size\tBlock no.\n");
    for (int i = 0; i < n; i++)
    {
        printf(" %d\t\t", i + 1);
        printf("%d\t\t", processSize[i]);
        if (allocated[i] != -1)
        {
            printf("%d", allocated[i] + 1);
        }
        else
        {
            printf("Not Allocated");
        }
        printf("\n");
    }
}

void main()
{
    int m, n;
    printf("Enter number of blocks : ");
    scanf("%d", &m);
    printf("Enter number of processes : ");
    scanf("%d", &n);
    int blockSize[m], processSize[n];

    for (int i = 0; i < m; i++)
    {
        printf("Enter size of block %d : ", i + 1);
        scanf("%d", &blockSize[i]);
    }
    printf("\n");
    for (int i = 0; i < n; i++)
    {
        printf("Enter size of process %d : ", i + 1);
        scanf("%d", &processSize[i]);
    }

    bestFit(m, n, blockSize, processSize);
}


5
4
100 500 200 300 600
212 417 112 426







3. Worst Fit





#include <stdio.h>

void worstFit(int m, int n, int blockSize[], int processSize[])
{
    int allocated[n];
    for (int i = 0; i < n; i++)
    {
        allocated[i] = -1;
    }

    for (int i = 0; i < n; i++)
    {
        int worstIndex = -1;
        for (int j = 0; j < m; j++)
        {
            if (blockSize[j] >= processSize[i])
            {
                if (worstIndex == -1)
                {
                    worstIndex = j;
                }
                else if (blockSize[worstIndex] < blockSize[j])
                {
                    worstIndex = j;
                }
            }
        }

        if (worstIndex != -1)
        {
            allocated[i] = worstIndex;
            blockSize[worstIndex] -= processSize[i];
        }
    }

    printf("\nProcess No. \tProcess Size\tBlock No.\n");
    for (int i = 0; i < n; i++)
    {
        printf("%d\t\t", i + 1);
        printf("%d\t\t", processSize[i]);
        if (allocated[i] != -1)
        {
            printf("%d", allocated[i] + 1);
        }
        else
        {
            printf("Not Allocated");
        }
        printf("\n");
    }
}

void main()
{
    int m, n;
    printf("Enter number of blocks : ");
    scanf("%d", &m);
    printf("Enter number of processes : ");
    scanf("%d", &n);
    int blockSize[m], processSize[n];

    for (int i = 0; i < m; i++)
    {
        printf("Enter size of block %d : ", i + 1);
        scanf("%d", &blockSize[i]);
    }
    printf("\n");
    for (int i = 0; i < n; i++)
    {
        printf("Enter size of process %d : ", i + 1);
        scanf("%d", &processSize[i]);
    }
    worstFit(m, n, blockSize, processSize);
}


5
4
100 500 200 300 600
212 417 112 426




4. Next Fit



#include <stdio.h>

void nextfit(int m, int n, int block[], int process[]) {
    int allocation[n];
    for (int i = 0; i < n; i++) {
        allocation[i] = -1;
    }

    for (int i = 0; i < n; i++) {
        int count = 0;
        int j = 0;
        while (count < m) {
            if (block[j] >= process[i]) {
                allocation[i] = j;
                block[j] -= process[i];
                break;
            }
            j = (j + 1) % m;
            count++;
        }
    }

    printf("\nProcess No.\tProcess size\tblock no\n");
    for (int i = 0; i < n; i++) {
        printf(" %d\t\t", i + 1);
        printf("%d\t\t", process[i]);
        if (allocation[i] != -1) {
            printf("%d\n", allocation[i] + 1);
        } else {
            printf("not allocated");
        }
        printf("\n");
    }
}

int main() {
    int m, n;
    printf("Enter number of blocks: ");
    scanf("%d", &m);
    printf("Enter number of processes: ");
    scanf("%d", &n);

    int block[m];
    int process[n];

    for (int i = 0; i < m; i++) {
        printf("Enter size of block: ");
        scanf("%d", &block[i]);
    }

    for (int i = 0; i < n; i++) {
        printf("Enter size of process: ");
        scanf("%d", &process[i]);
    }

    nextfit(m, n, block, process);

    return 0;
}


5
4
100 500 200 300 600
212 417 112 426








///// Conversion of Logical / virtual address into  physical address







#include <stdio.h>
 
#define PAGE_SIZE 1024 // Page size 
 
// Page table 
struct page_table{
    int virtual_page;
    int frame; 
}pg_table[10];
 
int main() {
 
    int page_size = PAGE_SIZE; 
    int virtual_address, virtual_page_no, offset;
    int frame_no, physical_address;
 
    // Initialize page table  
    pg_table[0].virtual_page = 0;
    pg_table[0].frame = 1;
 
    pg_table[1].virtual_page = 1;
    pg_table[1].frame = 3;
    
    // Input virtual address
    printf("Enter virtual address: ");
    scanf("%d", &virtual_address);
 
    // Extract virtual page number and offset
    virtual_page_no = virtual_address / page_size;
    offset = virtual_address % page_size;
 
    // Get frame number from page table
    frame_no = pg_table[virtual_page_no].frame;
 
    // Calculate physical address 
    physical_address = (frame_no * page_size) + offset;
 
    printf("The physical address is: %d", physical_address);
 
    return 0;
}















/////  Virtual/ logical address in physical address using segmentation and paging






#include <stdio.h>
#include <math.h>

int main() {
    int logicalAddress;
    int segmentSize, pageSize;
    int segmentNumber, segmentOffset, pageNumber, pageOffset;
    int physicalAddress;

    // Taking user input for segment and page sizes
    printf("Enter segment size: ");
    scanf("%d", &segmentSize);
    printf("Enter page size: ");
    scanf("%d", &pageSize);

    // Taking user input for logical address
    printf("Enter logical address: ");
    scanf("%d", &logicalAddress);

    // Calculate segment number and offset
    segmentNumber = logicalAddress / segmentSize;
    segmentOffset = logicalAddress % segmentSize;

    // Calculate page number and offset
    pageNumber = segmentOffset / pageSize;
    pageOffset = segmentOffset % pageSize;

    // Assuming we have a page table, convert page number to physical frame number
    int pageTable[] = {2, 0, 1}; // Example page table
    int frameNumber = pageTable[pageNumber];

    // Calculate physical address
    physicalAddress = frameNumber * pageSize + pageOffset;

    // Print results
    printf("Segment Number: %d\n", segmentNumber);
    printf("Segment Offset: %d\n", segmentOffset);
    printf("Page Number: %d\n", pageNumber);
    printf("Page Offset: %d\n", pageOffset);
    printf("Frame Number: %d\n", frameNumber);
    printf("Physical Address: %d\n", physicalAddress);

    return 0;
}
